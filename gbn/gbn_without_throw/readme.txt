没有按照老师课件的ppt演示做
老师的接收端每次收到靠后的分组时，忽略，并且发送一个靠前的已经发送过的老ack
我做的是收到不需要的包不发送ack，参考
https://www.youtube.com/watch?v=Cs8tR8A9jm8
https://www.youtube.com/watch?v=ZLtkhsgQp8U

Go Back N means: 如果有一个包超时，他就会变成窗口的起点，从这个起点重新发送N个包(本来已经把发N+windowssize-1包发送出去了，但是要返回N，重新发)

如果当前包丢失了，显然不会收到当前包的ack，而是会超时
但是如果当前包发送成功，但是当前包的ack丢失了，那么接收端的ack就是会靠后，并且返回真实的ack，这会比当前包靠后
这个问题的解决方案：
发送端每次recvfrom到一个ack，都对发送窗口内的所有点进行检测，如果ack比他们大，就发送这个点。
但是这会带来一个问题，那就是在网络无错误的情况下，一个点会发送|windowsize-i+1|次，i是当前点的编号(0, 1, 2, ...N-1)，如图1所示
改进方案：发送端的每个点收到等于自己的ack时，发送包|自己+N|，收到大于自己的ack，并且自己没有发送包|自己+N|，那就发一次，这需要每个点都设置一个flag来判断，确保包|自己+N|只被发送一次。如图2所示



窗口的size是pow(2, M)-1，但是ack以及Yn号是% pow(2, M)