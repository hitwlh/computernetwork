参考
http://book.2cto.com/201212/12704.html

Go Back N means: 如果有一个包超时，即使它后面的包全部成功发送出去了，他还是会变成窗口的起点，从这个起点重新发送N个包

如果当前包丢失了，显然不会收到当前包的ack，而是会超时
但是如果当前包发送成功，但是当前包的ack丢失了，那么接收端的ack就是会靠后，并且返回真实的ack，这会比当前包靠后
但是由于接收到的是靠后的ack，所以窗口自然要往前滑



窗口的size是%(pow(2, M) - 1)，但是ack以及Yn号是% pow(2, M)

这个版本的实现得不高效：发送的时候是用了for循环直接把整个窗口发出去，然后再进入下一阶段接受所有ack，因此只适用于延迟比较高的网络，如果发送窗口还没发送完，但是接收端发的ack已经到达发送端，正确的做法应该是让窗口滑动并且这个包应该在这个阶段进行发送，而不是等到下一阶段。

但是这个问题貌似无解：我实现的是同一批ack里挑选最大的，以防止ack乱序到达
如果改成每次到达一个ack就滑动窗口，同一批次的ack，可能先到ack3，滑动窗口到3， 再到ack1，又往前滑动到1，这就出错了！